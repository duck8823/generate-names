package net.duck8823;


import com.google.auto.common.MoreElements;
import com.squareup.javapoet.*;

import javax.annotation.Generated;
import javax.annotation.processing.AbstractProcessor;
import javax.annotation.processing.RoundEnvironment;
import javax.annotation.processing.SupportedAnnotationTypes;
import javax.annotation.processing.SupportedSourceVersion;
import javax.lang.model.SourceVersion;
import javax.lang.model.element.Element;
import javax.lang.model.element.Modifier;
import javax.lang.model.element.PackageElement;
import javax.lang.model.element.TypeElement;
import javax.tools.JavaFileObject;
import java.io.IOException;
import java.io.Writer;
import java.util.HashSet;
import java.util.Set;

/**
 * アノテーションプロセッサの実装
 * Created by maeda on 2016/01/09.
 */
@SupportedSourceVersion(SourceVersion.RELEASE_8)
@SupportedAnnotationTypes("*")
public class GenerateNamesProcessor extends AbstractProcessor {

	@Override
	public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {
		final Set<? extends Element> elements = roundEnv.getElementsAnnotatedWith(GenerateNames.class);
		for(final Element element : elements){
			final PackageElement packageElement = MoreElements.getPackage(element);
			TypeSpec.Builder builder = TypeSpec.classBuilder(element.getSimpleName().toString() + "Names");
			AnnotationSpec generated = AnnotationSpec.builder(Generated.class)
													 .addMember("value", "$S", "net.duck8823.GenerateNamesProcessor")
													 .build();

			builder.addAnnotation(generated)
				   .addModifiers(Modifier.PUBLIC)
				   .addJavadoc("Generated by generate-names.\n")
				   .addJavadoc("@see https://github.com/duck8823/generate-names\n");

			builder.addMethods(findFields(element));
			final TypeSpec nameClass = builder.build();
			JavaFile javaFile = JavaFile.builder(packageElement.getQualifiedName().toString(), nameClass).build();

			try {
				JavaFileObject sourceFile = processingEnv.getFiler().createSourceFile(element.toString() + "Names");
				Writer writer = sourceFile.openWriter();
				javaFile.writeTo(writer);
				writer.close();
			} catch (IOException e){
				throw new RuntimeException(e);
			}
		}

		return true;
	}

	/**
	 * {@param element}内のフィールドを取得する
	 * @param element クラス要素
	 */
	private Set<MethodSpec> findFields(Element element) {
		return findFields(element, new HashSet<>());
	}

	/**
	 * {@param element}内のフィールドを取得する
	 * @param element クラス要素
	 * @param contains 既に含まれる要素名のセット
	 */
	private Set<MethodSpec> findFields(Element element, HashSet<String> contains) {
		Set<MethodSpec> methodSpecs = new HashSet<>();
		final TypeElement typeElement = (TypeElement) element;
		typeElement.getEnclosedElements().stream().filter(o -> o.getKind().isField()).filter(o -> !contains.contains(o.toString())).forEach( o -> {
			MethodSpec methodSpec = MethodSpec.methodBuilder(o.toString())
											  .addModifiers(Modifier.PUBLIC, Modifier.FINAL)
											  .returns(String.class)
											  .addCode("return $S;\n", o.toString())
											  .addJavadoc("$Lのフィールド名を取得します.\n@return $Lのフィールド名\n", o.toString(), o.toString())
											  .build();
			methodSpecs.add(methodSpec);
		});
		Element superclassElement = processingEnv.getTypeUtils().asElement(typeElement.getSuperclass());
		if(superclassElement != null) {
			methodSpecs.addAll(findFields(superclassElement, contains));
		}
		return methodSpecs;
	}
}
